#include <google/protobuf/compiler/nim/nim_generator.h>

#include <google/protobuf/descriptor.h>
#include <google/protobuf/io/printer.h>
#include <google/protobuf/io/zero_copy_stream.h>


#include <google/protobuf/stubs/strutil.h>

namespace google {
namespace protobuf {
namespace compiler {
namespace nim {

    std::string EnumName(const EnumDescriptor* enumDescriptor)
    {
        string enum_name = enumDescriptor->name();
        const Descriptor* descriptor = enumDescriptor->containing_type();
        while (descriptor != NULL) {
            enum_name = descriptor->name() + '_' + enum_name;
            descriptor = descriptor->containing_type();
        }

        return enum_name;
    }

    void GenerateEnum(const EnumDescriptor* enumDescriptor, io::Printer* printer)
    {
        printer->Print("type\n");
        printer->Indent();
        printer->Print(
            "^enumName^* = enum\n",
            "enumName", EnumName(enumDescriptor));

        printer->Indent();
        for (size_t i = 0; i < enumDescriptor->value_count(); i++)
        {
            printer->Print(
                "^name^ = ^number^,\n",
                "name", enumDescriptor->value(i)->name(),
                "number", SimpleItoa(enumDescriptor->value(i)->number()));
        }
        printer->Outdent();
        printer->Outdent();
        printer->Print("\n");
    }

    std::string MessageName(const Descriptor* message)
    {
        string message_name = message->name();
        const Descriptor* descriptor = message->containing_type();
        while (descriptor != NULL) {
            message_name = descriptor->name() + '_' + message_name;
            descriptor = descriptor->containing_type();
        }
        
        return message_name;
    }

    void GenerateFieldDefs(const Descriptor* message, io::Printer* printer)
    {
        const OneofDescriptor* declaringOneof = NULL;
        for (size_t i = 0; i < message->field_count(); i++)
        {
            const FieldDescriptor* field = message->field(i);
            string type;
            const OneofDescriptor* oneof = field->containing_oneof();
            if (oneof != NULL && declaringOneof != oneof)
            {   // Open new oneof type definition
                declaringOneof = oneof;
                printer->Print(
                    "PbOneOf ^oneofName^:\n",
                    "oneofName", oneof->name());
            }

            if (field->type() == FieldDescriptor::TYPE_ENUM)
            {
                type = EnumName(field->enum_type());
            }
            else
            {   // Value types
                type = field->type_name();
                type[0] = toupper(type[0]);
                type = "Pb" + type;
            }
            if (oneof != NULL) printer->Indent();
            printer->Print(
                "^name^: ^type^ @^number^\n",
                "name", field->name(),
                "type", type,
                "number", SimpleItoa(field->number()));
            if (oneof != NULL) printer->Outdent();
        }
    }

    void GenerateWriteToFunc(const Descriptor* message, io::Printer* printer)
    {
        printer->Print(
            "proc WriteTo*(message: ^messageName^, output: var CodedOutputStream) =\n",
            "messageName", MessageName(message));
        printer->Indent();
        printer->Print("PbWriteTo(message, output)\n");
        printer->Outdent();
        printer->Print("\n");
    }

    void GenerateMergeFromFunc(const Descriptor* message, io::Printer* printer)
    {
        printer->Print(
            "proc MergeFrom*(message: var ^messageName^, input: CodedInputStream) =\n",
            "messageName", MessageName(message));
        printer->Indent();
        printer->Print("PbMergeFrom(message, input)\n");
        printer->Outdent();
        printer->Print("\n");
    }

    void GenerateMessage(const Descriptor* message, io::Printer* printer)
    {
        for (size_t i = 0; i < message->nested_type_count(); i++)
        {
            GenerateMessage(message->nested_type(i), printer);
        }

        printer->Print(
            "PbMessage ^messageName^:\n",
            "messageName", MessageName(message));

        printer->Indent();
        GenerateFieldDefs(message, printer);
        printer->Outdent();
        printer->Print("\n");

        GenerateWriteToFunc(message, printer);
        GenerateMergeFromFunc(message, printer);
    }

    void GenerateFile(const FileDescriptor* file, io::Printer* printer)
    {
        printer->Print(
            "# Generated by the protocol buffer compiler.  DO NOT EDIT!\n"
            "# source: ^filename^\n"
            "\n"
            "import protobuf\n"
            "\n",
            "filename", file->name());

        for (size_t i = 0; i < file->enum_type_count(); i++)
        {
            GenerateEnum(file->enum_type(i), printer);
        }

        for (size_t i = 0; i < file->message_type_count(); i++)
        {
            GenerateMessage(file->message_type(i), printer);
        }
    }

    std::string StripDotProto(const std::string& proto_file) {
        int lastindex = proto_file.find_last_of(".");
        return proto_file.substr(0, lastindex);
    }

    std::string GetFileNameBase(const FileDescriptor* descriptor) {
        std::string proto_file = descriptor->name();
        int lastslash = proto_file.find_last_of("/");
        std::string base = proto_file.substr(lastslash + 1);
        return StripDotProto(base);
    }

    bool Generator::Generate(const FileDescriptor* file, const string& parameter,
        GeneratorContext* generator_context, string* error) const
    {
        if (file->syntax() != FileDescriptor::SYNTAX_PROTO3)
        {
            *error =
                "Can only generate nim code for proto3 .proto files.\n"
                "Please add 'syntax = \"proto3\";' to the top of your .proto file.\n";
            return false;
        }

        string filename = GetFileNameBase(file) + ".nim";
        scoped_ptr<io::ZeroCopyOutputStream> output(generator_context->Open(filename));
        io::Printer printer(output.get(), '^');

        GenerateFile(file, &printer);
        return true;
    }
}  // namespace nim
}  // namespace compiler
}  // namespace protobuf
}  // namespace google
