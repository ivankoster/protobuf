#include <google/protobuf/compiler/nim/nim_generator.h>

#include <google/protobuf/descriptor.h>
#include <google/protobuf/io/printer.h>
#include <google/protobuf/io/zero_copy_stream.h>


#include <google/protobuf/stubs/strutil.h>

namespace google {
namespace protobuf {
namespace compiler {
namespace nim {

    std::string MessageName(const Descriptor* message)
    {
        string message_name = message->name();
        const Descriptor* descriptor = message->containing_type();
        while (descriptor != NULL) {
            message_name = descriptor->name() + '_' + message_name;
            descriptor = descriptor->containing_type();
        }
        
        return message_name;
    }

    std::string TypeForField(const FieldDescriptor* field) 
    {
        switch (field->type()) {
        case FieldDescriptor::TYPE_MESSAGE: return MessageName(field->message_type());
        case FieldDescriptor::TYPE_INT32: return "int32";
        case FieldDescriptor::TYPE_INT64:
        case FieldDescriptor::TYPE_UINT32:
        case FieldDescriptor::TYPE_UINT64:
        case FieldDescriptor::TYPE_SINT32:
        case FieldDescriptor::TYPE_SINT64:
        case FieldDescriptor::TYPE_FIXED32:
        case FieldDescriptor::TYPE_FIXED64:
        case FieldDescriptor::TYPE_SFIXED32:
        case FieldDescriptor::TYPE_SFIXED64:
        case FieldDescriptor::TYPE_ENUM:
        case FieldDescriptor::TYPE_DOUBLE:
        case FieldDescriptor::TYPE_FLOAT:
        case FieldDescriptor::TYPE_BOOL:
        case FieldDescriptor::TYPE_STRING:
        case FieldDescriptor::TYPE_BYTES:
        case FieldDescriptor::TYPE_GROUP: return "typeNotImplementedYet";
        default: assert(false); return "";
        }
    }

    void GenerateWriteToFunc(const Descriptor* message, io::Printer* printer)
    {
        printer->Print(
            "proc WriteTo*(message: ^messageName^, output: var CodedOutputStream) =\n",
            "messageName", MessageName(message));
        printer->Indent();
        printer->Print("PbWriteTo(message, output):\n");
        printer->Indent();
        for (size_t i = 0; i < message->field_count(); i++)
        {
            const FieldDescriptor* field = message->field(i);
            string type = field->type_name();
            type[0] = toupper(type[0]);
            printer->Print(
                "^name^: Pb^type^ @^number^\n",
                "name", field->name(),
                "type", type,
                "number", SimpleItoa(field->number()));
        }
        printer->Print("\n");
        printer->Outdent();
        printer->Outdent();
    }

    void GenerateMessage(const Descriptor* message, io::Printer* printer)
    {
        for (size_t i = 0; i < message->nested_type_count(); i++)
        {
            GenerateMessage(message->nested_type(i), printer);
        }

        printer->Print("type\n");
        printer->Indent();
        printer->Print(
            "^messageName^ = object\n",
            "messageName", MessageName(message));

        printer->Indent();
        for (size_t i = 0; i < message->field_count(); i++)
        {
            const FieldDescriptor* field = message->field(i);
            if (field->is_repeated())
            {
                printer->Print("repeated ");
            }
            printer->Print(
                "^name^: ^type^\n",
                "name", field->name(),
                "type", TypeForField(field));
        }
        printer->Outdent();
        printer->Outdent();
        printer->Print("\n");

        GenerateWriteToFunc(message, printer);
    }

    void GenerateFile(const FileDescriptor* file, GeneratorContext* generator_context)
    {
        for (size_t i = 0; i < file->message_type_count(); i++)
        {
            string filename = MessageName(file->message_type(i)) + ".nim";
            scoped_ptr<io::ZeroCopyOutputStream> output(generator_context->Open(filename));
            io::Printer printer(output.get(), '^');
            printer.Print(
                "# Generated by the protocol buffer compiler.  DO NOT EDIT!\n"
                "# source: ^filename^\n"
                "\n"
                "import protobuf\n"
                "\n",
                "filename", file->name());

            GenerateMessage(file->message_type(i), &printer);
        }
    }

    bool Generator::Generate(const FileDescriptor* file, const string& parameter,
        GeneratorContext* generator_context, string* error) const
    {
        if (file->syntax() != FileDescriptor::SYNTAX_PROTO3)
        {
            *error =
                "Can only generate nim code for proto3 .proto files.\n"
                "Please add 'syntax = \"proto3\";' to the top of your .proto file.\n";
            return false;
        }
        GenerateFile(file, generator_context);
        return true;
    }
}  // namespace nim
}  // namespace compiler
}  // namespace protobuf
}  // namespace google
